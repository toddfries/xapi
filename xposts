#!/usr/bin/perl

# Copyright (c) 2022-2024 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use utf8;
use open qw/:std :utf8/;

use Data::Dumper;
use Date::Manip;
use Getopt::Std;
use POSIX qw(strftime);
use ReadConf;
use Sys::Syslog;
use X::API;
use JSON;
use MIME::Base64;
use Storable qw(freeze thaw);
use Digest::SHA1 qw(sha1_hex);
use Graphics::Magick;
use File::MMagic;

$Data::Dumper::Indent = 2;
$Data::Dumper::Purity = 1;
$Data::Dumper::Deepcopy = 1;
$Data::Dumper::Sortkeys = 1;


my $ident = "Xposts";
my $logopt = 'pid';
my $facility = 'user';

our $cachedir = $ENV{'HOME'}."/.cache/xposts";
our $magic;
mkdir($ENV{'HOME'}.".cache") if ! -d $ENV{'HOME'}."/.cache";
mkdir($cachedir) if ! -d $cachedir;
if (! -d $cachedir) {
	die "Can't create $cachedir";
}

# XXX crude global hack, think of a better solution!
#   .. the problem is if I call eval { function; };
#   .. and that function also calls eval { foo; };
#   .. and that function also calls die
#   .. the program actually dies
#   .. want to see if post replies die, then query the community_id incase thats why
our $skipeval = 0;
our @followq;

our $fields = { }; # ->{p} = post, ->{u} = user
init_fields();

our $opt_b; # shows bookmarks
our $opt_c; # config file
our $opt_j; # arbitrary v2 query to get json output
our $opt_J; # arbitrary v1 query to get json output
our $opt_l; # chase likes
our $opt_q; # quiet
our $opt_r; # desired resutls count
our $opt_s; # show users profile stats
our $opt_S; # show users profile stats
our $opt_T; # show an individual post
our $opt_v; # verbosity
our $opt_L; # show owned lists
our $opt_N; # no syslog
our $opt_O; # var=val1,val2,val3;var2=val4,val5;var3=val6
our $opt_p; # arbitrary v2 query to post json output call;var1=val1;var2=val2

our $opt_w; # write a post, $opt_w is message
our $opt_Q; #  post quote id (post id to quote)
our $opt_R; #  post reply_settings { "mentionedUsers", "followers", "everyone", "" }
our $opt_C; #  post community_id
our $opt_W; #  post reply id (post id to reply to)
our $opt_I; #  post image filename
our $opt_i; #  post image filename
our $opt_d; # write a dm message $opt_d is uid, $ARGV[0] is message
our $opt_B; # '-B postid' bookmark postid
our $opt_u; # upload a media file and get an id

our $opt_a; # generic action with argument

# defaults
$opt_b = 0;
$opt_c = $ENV{HOME}."/.config/xapi/xapi.conf";
$opt_l = 0;
$opt_L = 0;
$opt_r = 10;
$opt_s = 0;
$opt_v = 0;

getopts('a:bc:d:j:lp:qr:su:vw:B:I:J:Q:ST:LNO:W:');

$opt_I //= $opt_i;

if (! -f $opt_c) {
	die "Config file '${opt_c}' EEXIST";
}

my $rc = ReadConf->new();
my $conf = $rc->readconf($opt_c);

my $section = "creds";

our $opts = { };
if (defined($opt_O)) {
	for my $opt (split(/;/,$opt_O)) {
		if ($opt =~ /^([^=]+)=(.*)$/) {
			my ($var, $val) = ($1, $2);
			$opts->{$var} = $val;
		}
	}
}

my $c = $conf->{creds};

if (!defined($c)) {
	die "[creds] not found in xapi.conf";
}

if (!defined($c->{cache_prefix})) {
	die "[creds]cache_prefix not found";
}
my $cache_prefix = $c->{cache_prefix};
$cachedir .= "/${cache_prefix}";
mkdir($cachedir);
if (! -d $cachedir) {
	die "Could not mkdir($cachedir)";
}

our $me_glob;
my $api_url = 'https://api.x.com';
if (defined $opts->{api_url}) {
	$api_url = $opts->{api_url};
}

our $client = { };
$client->{1} = X::API->new_with_traits(
	#api_version => '1',
	#api_ext	=> '',
	traits => [ qw/ApiMethods/ ],
	#traits => [ qw/Enchilada/ ],
	agent => "v1UserLookupJS",
	consumer_key	=> $c->{consumer_key},
	consumer_secret => $c->{consumer_secret},
	access_token	=> $c->{access_token},
	access_token_secret => $c->{access_token_secret},
	api_url => $api_url,
);
#print Dumper($client->{1});
$client->{2} = X::API->new_with_traits(
	api_version => '2',
	api_ext	=> '',
	traits => [ qw/ApiMethods/ ],
	#traits => [ qw/Enchilada/ ],
	consumer_key	=> $c->{consumer_key},
	consumer_secret => $c->{consumer_secret},
	access_token	=> $c->{access_token},
	access_token_secret => $c->{access_token_secret},
	api_url => $api_url,
);
#print Dumper($client->{2});

our $gc = { }; # Global Cache
our $pmemcache = { }; # posts
our $mmemcache = { }; # media
our $smemcache = { }; # stats

our $v = $opt_v;

if (!defined $opt_N) {
	openlog($ident, $logopt, $facility);
}

if ($opt_s>0) {
	show_mystats();
	exit(0);
}

if (defined($opt_j)) {
	my ($data, $c) = get2( $opt_j );
	print Dumper($data);
	exit(0);
}
if (defined($opt_J)) {
	my ($data, $c) = get1( $opt_J );
	print Dumper($data);
	exit(0);
}
	
	

if ($opt_b>0) {
	show_bookmarks();
	exit(0);
}

if (defined($opt_T)) {
	use Try::Tiny;
	# The `expansions` query parameter value [foo] is not one of [author_id,referenced_tweets.id,referenced_tweets.id.author_id,entities.mentions.username,entities.note.mentions.username,attachments.poll_ids,attachments.media_keys,attachments.media_source_tweet,in_reply_to_user_id,geo.place_id,edit_history_tweet_ids,article.cover_media,article.media_entities]
	my $query = "tweet.fields=".$fields->{p}.
	"&expansions=author_id,entities.mentions.username,in_reply_to_user_id,referenced_tweets.id,attachments.media_keys".
	# media_fields [alt_text,duration_ms,height,media_key,non_public_metrics,organic_metrics,preview_image_url,promoted_metrics,public_metrics,type,url,variants,width]
	"&media.fields=url,variants,media_key,type,alt_text,duration_ms,public_metrics".
	# user.fields [created_at,description,entities,id,location,name,pinned_tweet_id,profile_image_url,protected,public_metrics,url,username,verified,verified_type,withheld]
	"&user.fields=username,withheld,protected,created_at,public_metrics,verified,verified_type";
	#$query = "tweet.fields=lang,author_id,attachments,created_at,public_metrics&user.fields=created_at";
	#$query = "tweet.fields=created_at&expansions=author_id&user.fields=created_at";
	for my $t (split(/\s+,\s+/,$opt_T)) {
		my ($posts, $context);

		($posts, $context) = get2("posts?ids=${t}&$query");
		print expand_tweet(0, $posts);
	}
	exit(0);
}

if (defined($opt_u)) {
	my $file = $opt_u;
	if (! -f $file ) {
		die "file $file EEXISTS";
	}
	my $mdata = file_to_mediaid( $file );
	
	printf "media_id=%s name=%s\n", $mdata->{media_id}, $file;
	exit(0);
}
if (defined($opt_a)) {
	if ($opt_a eq "like") {
		like(@ARGV);
		exit(0);
	}
	if ($opt_a eq "desc") {
		desc(@ARGV);
		exit(0);
	}
	if ($opt_a eq "uinfo") {
		my $data = uinfo();
		print Dumper($data);
		exit(0);
	}
	if ($opt_a eq "mystats") {
		show_mystats();
		exit(0);
	}
	if ($opt_a eq "delete") {
		my ($data, $c) = delete2($ARGV[0]);
		print Dumper($data);
		exit(0);
	}
	if ($opt_a eq "get2") {
		my ($data, $c) = get2( $ARGV[0] );
		print Dumper($data);
		exit(0);
	}
	if ($opt_a eq "get1") {
		my ($data, $c) = get1( $ARGV[0] );
		print Dumper($data);
		exit(0);
	}
	if ($opt_a eq "post2") {
		my ($call,@payloads) = split(/;/,$ARGV[0]);
		my $req = { };
		for my $part ( @payloads ) {
			my ($var,$val) = split(/=/,$part);
			$req->{$var} = $val;
		}
		my ($data, $c) = post2($call,$req);
		exit(0);
	}
	if ($opt_a eq "post") {
		xpost($ARGV[0]);
		exit(0);
	}
	if ($opt_a eq "follow") {
		for my $arg (@ARGV) {
			for my $user (split(/[,; ]/, $arg)) {
				qfollow($user);
			}
		}
		for my $user (@followq) {
			my @list = getuser_byname($user);
			for my $data (@list) {
				my $uid = $data->{id};
				qfollowid($uid);
			}
		}
		exit(0);
	}
	if ($opt_a eq "getuinfo") {
		my @list = getuser_byname(@ARGV);
		for my $data (@list) {
			print "getuser_byname res: ".Dumper($data);
		}
		exit(0);
	}
	die "unknown action ${opt_a}";
}
if (defined($opt_w)) {
	my $msg = $opt_w;
	xpost($msg);
	exit(0);
}

if (defined($opt_B)) {
	my $postid = $opt_B;
	my $req = { tweet_id => $postid };
	my $uid = uinfo()->{id};
	my ($data, $c) = post2("users/$uid/bookmarks", $req);
	print Dumper(($data,$c));
	exit(0);
}
if (defined($opt_d)) {
	my $uid = $opt_d;
	my $msg = $ARGV[0];
	my $req = { text => $msg };
	my ($data,$c) = post2("dm_conversations/with/${uid}/messages", $req);
	print Dumper(($data,$c));
	exit(0);
}
if (defined($opt_p)) {
	my ($call,@payloads) = split(/;/,$opt_p);
	my $req = { };
	for my $part ( @payloads ) {
		my ($var,$val) = split(/=/,$part);
		$req->{$var} = $val;
	}
	my ($data, $c) = post2($call,$req);
	exit(0);
}
my $who = $ARGV[0];
if (!defined($who)) {
	die "need a username on cli";
}

if (defined($opt_S)) {
	for my $who (@ARGV) {
		show_ustats($who);
	}
	exit(0);
}

my $maxres = $opt_r;

# Seriously, the api can't do < 5. So request 5, and count 'm ourself.
if ($maxres < 5) {
	$maxres = 5;
}
# rather than error out, cap it at max.
# XXX in the future, consider repeat querying for 100?
if ($maxres > 100) {
	$maxres = 100;
}

if ($opt_L>0) {
	show_owned_lists($who);
	exit(0);
}

my @list = getuser_byname($who);
my $data = $list[0];
my $id = $data->{id};


our $postfields = "tweet.fields=author_id,";
$postfields .= "created_at,";
#$postfields .= "context_annotations,"; # what concepts 
$postfields .= "entities,";
$postfields .= "public_metrics,";
#$postfields .= "non_public_metrics,"; # be sure to only enable this on posts I actually sent myself
$postfields .= "referenced_tweets,";
$postfields .= "in_reply_to_user_id,";
$postfields .= "conversation_id";

my ($posts, $context) = get2("users/${id}/posts".
	"?${postfields}".
	"&expansions=author_id,entities.mentions.username,in_reply_to_user_id,referenced_tweets.id,attachments.media_keys".
	"&media.fields=url,variants,media_key,type".
	"&max_results=${maxres}");
our $shown = 1;
if ($v > 0) {
	$shown = 0;
}
if (!defined($posts)) {
	die("posts for $id returned undef");
}
if (!defined($opt_q)) {
	print expand_tweet(0, $posts);
}

1;

sub umcache_read {
	my ($var) = @_;

	return cache_read('u',$var);
}
sub umcache_write {
	my ($data) = @_;

	my $id = $data->{id};
	my $who = $data->{username};
	print "umcache miss ${who}"."[$id]\n";

	#print "user: ".Dumper($user);

	# double mem use but easier lookup

	cache_write('u', $id, $data);
	cache_write('u', $who, $data);
}

sub cache_read {
	my ($cname, $var) = @_;

	my $data = $gc->{$cname}->{$var};
	$data //= read_from_cache("${cname}.${var}");
	return $data;

}
sub cache_write {
	my ($cname, $var, $val) = @_;
	$gc->{$cname}->{$var} = $val;
	write_to_cache("${cname}.${var}", $val);
}

sub init_fields {
	$fields = { };
	$fields->{p} = "";
	$fields->{p} .= "article,";
	$fields->{p} .= "attachments,";
	$fields->{p} .= "author_id,";
	$fields->{p} .= "card_uri,";
	$fields->{p} .= "context_annotations,";
	$fields->{p} .= "community_id,";
	$fields->{p} .= "conversation_id,";
	$fields->{p} .= "created_at,";
	$fields->{p} .= "display_text_range,";
	$fields->{p} .= "edit_controls,";
	$fields->{p} .= "edit_history_tweet_ids,";
	$fields->{p} .= "entities,";
	$fields->{p} .= "geo,";
	$fields->{p} .= "id,";
	$fields->{p} .= "in_reply_to_user_id,";
	$fields->{p} .= "lang,";
	$fields->{p} .= "media_metadata,";
	$fields->{p} .= "note_tweet,";
	$fields->{p} .= "possibly_sensitive,";
	$fields->{p} .= "public_metrics,";
	$fields->{p} .= "referenced_tweets,";
	$fields->{p} .= "reply_settings,";
	$fields->{p} .= "scopes,";
	$fields->{p} .= "source,";
	$fields->{p} .= "text,";
	$fields->{p} .= "withheld";
	# logic this for only my tweets
	#$fields->{p} .= "promoted_metrics,";
	#$fields->{p} .= "non_public_metrics,";
	#$fields->{p} .= "organic_metrics,";

	$fields->{u} = "";
	$fields->{u} .= "connection_status,";
	$fields->{u} .= "created_at,";
	$fields->{u} .= "description,";
	$fields->{u} .= "entities,";
	$fields->{u} .= "id,";
	$fields->{u} .= "location,";
	$fields->{u} .= "most_recent_tweet_id,";
	$fields->{u} .= "name,";
	$fields->{u} .= "pinned_tweet_id,";
	$fields->{u} .= "profile_banner_url,";
	$fields->{u} .= "profile_image_url,";
	$fields->{u} .= "protected,";
	$fields->{u} .= "public_metrics,";
	$fields->{u} .= "receives_your_dm,";
	$fields->{u} .= "subscription_type,";
	$fields->{u} .= "url,";
	$fields->{u} .= "username,";
	$fields->{u} .= "verified,";
	$fields->{u} .= "verified_type,";
	$fields->{u} .= "verified_followers_count,";
	$fields->{u} .= "withheld";

	# expansions=
	$fields->{x}  = "";
	$fields->{x} .= "affiliation.user_id,";
	$fields->{x} .= "most_recent_tweet_id,";
	$fields->{x} .= "pinned_tweet_id";
}

sub uinfo {
	my $me = get_creds();
	my $uc = cache_read('u',$me->{screen_name});
	if (defined($uc)) {
		return $uc;
	}

	my $ufields = $fields->{u};

	my $tfields = $fields->{p};

	my ($data, $c) = get2("users/me?".
		"user.fields=$ufields&".
		"tweet.fields=$tfields");
	umcache_write($data->{data});
	return $data->{data};
}

sub getuser_byname {
	my (@ppl) = @_;

	my @ppldata = ();
	my @pplget = ();
	for my $who (@ppl) {
		my $data = cache_read('u',$who);
		if (defined($data)) {
			#print "ucache hit  ".$data->{id}."\n";
			push @ppldata, $data;
			next;
		}
		push @pplget, $who;
	}
	if ($#ppl == $#ppldata) {
		return @ppldata;
	}

	for my $who (@pplget) {
		my ($res,$c) = get2("users/by/username/$who?user.fields=".$fields->{u});
		if (!defined($res)) {
			die("empty result querying $who");
		}
		$data = $res->{data};
		if (!defined($data)) {
			if (defined $res->{errors}) {
				fmt_errors($res->{errors});
				next;
			}
			die("empty data ".Dumper($res));
		}
		if (!defined($data->{id})) {
			print "ENOID: ";
			die(Dumper($data));
		}
		if ($v>0) {
			print Dumper($data);
		}
		umcache_write($data);
		push @ppldata, $data;
	}

	return @ppldata;
}
sub getuser_byid {
	my ($id) = @_;

	my $data = cache_read('u',$id);
	if (defined($data)) {
		#print "ucache hit  ".$data->{id}."\n";
		return $data;
	}
	my $c;
	($data, $c) = get2("users/${id}");
	$data = $data->{data};

	umcache_write($data);

	return $data;
}

sub getmedia_bykey {
	my ($mkey) = @_;

	my $media = $mmemcache->{$mkey};
	if (defined($media)) {
		return $media;
	}

	# XXX to finish
}

sub expand_tweet {
	my ($level, $posts) = @_;

	my $returnstr = "";

	my $spacecount = $level * 4+1;
	my $prestr = sprintf "%${spacecount}s", $level;

	if ($v > 0) {
		print "\n\nposts: ".Dumper($posts)."\n\n";
	}

	for my $user ( @{ $posts->{includes}->{users} } ) {
		if (defined(cache_read('u',$user->{id}))) {
			next;
		}
		umcache_write($user);
	}
	for my $post ( @{ $posts->{includes}->{tweets} } ) {
		#die(" post: ". Dumper($post));
		my $tid = $post->{id};

		for my $var (%{ $post }) {
			$pmemcache->{$tid}->{$var} = $post->{$var};
		}

		# 'public_metrics' => { 'like_count' => 0, 'quote_count' => 0, 'retweet_count' => 0, 'reply_count' => 2 },
		if ($opt_l>0 && $post->{public_metrics}->{like_count} > 0 && !defined($pmemcache->{$tid}->{liking_users})) {
			my $pg = "";
			my $ucount = 0;
			while(1) {
			    my ($likes,$c) = get2("posts/${tid}/liking_users".
				"?max_results=100".
				#"&expansions=pinned_tweet_id".
				"&tweet.fields=conversation_id,entities,public_metrics".
				"&user.fields=public_metrics".
				$pg
			    );
			    for my $user (@{ $likes->{data} }) {
				$ucount++;
				    push @{$pmemcache->{$tid}->{liking_users}}, $user;
			    }
			    my $rc = $likes->{meta}->{result_count};
			    if (defined($likes->{meta}->{next_token})) {
				$pg="&pagination_token=".$likes->{meta}->{next_token};
				next;
			    }
			    $pmemcache->{$tid}->{liking_count} = $ucount;
			    last;
			}
		}
	}

	for my $media ( @{ $posts->{includes}->{media} } ) {
		my $mkey = $media->{media_key};

		for my $var (%{ $media }) {
			if (defined($mmemcache->{$mkey}->{$var})) {
				next;
			}
			$mmemcache->{$mkey}->{$var} = $media->{$var};
		}
	}

	my $tcount = 0;
	for my $post ( @{ $posts->{data} } ) {
		if ($tcount++ >= $opt_r) {
			last;
		}
		my $tid = $post->{id};
		my $username = getuser_byid($post->{author_id})->{username};
		my $status = "";
		my $rstr = "";
		my $text = "";
		for my $ref ( @{ $post->{referenced_tweets} } ) {
			my $tstr = $ref->{type};
			my $recurse = 0;
			if ($ref->{type} eq "replied_to") {
				$tstr = "Re";
				$status = "RP ";
				$recurse++;
			} elsif ($ref->{type} eq "retweeted") {
				$tstr = "Rt";
				$status = "RT ";
				$recurse++;
			} elsif ($ref->{type} eq "quoted") {
				$tstr = "Quote";
				$status = "Q ";
				$recurse++;
			} else {
				$tstr = "Unknown(type=".$ref->{type}.")";
				$status = "? ";
			}
			if ($recurse > 0) {
				my ($q,$c) = get2("posts".
				    "?ids=".$ref->{id}.
				    "&expansions=author_id,entities.mentions.username,in_reply_to_user_id,referenced_tweets.id,attachments.media_keys".
				    "&${postfields}".
				    "&media.fields=url,variants,media_key,type"
				);
				$text .= expand_tweet($level + 1, $q );
			}
			if (length($rstr) > 0) {
				$rstr .= ", ";
			}
			$rstr .= sprintf "%s %s", $tstr, $ref->{id};
			#print "ref dump: ".Dumper($ref);
			#print "\n";
		}
		if (length($rstr)>0) {
			$rstr = ", $rstr";
		}
		my $ttext = $post->{text};
		$ttext =~ s/[\n\r\f]/ /sg;
		$ttext =~ s/\s+/ /g;
		$ttext =~ s/\&amp;/\&/g;

		$returnstr .= sprintf "%s%25s \@%s %s%s (%d%s)\n", $prestr, $post->{created_at}, $username, $status, $ttext, $tid, $rstr;
		my ($plike, $prt, $preply, $pimp, $pquote) = (
			$post->{public_metrics}->{like_count},
			$post->{public_metrics}->{retweet_count},
			$post->{public_metrics}->{impression_count},
			$post->{public_metrics}->{quote_count},
		);

		$plike  //= 0;
		$prt    //= 0;
		$preply //= 0;
		$pquote //= 0;
		$pimp   //= 0;
		$returnstr .= sprintf "%s%25s %d/%d/%d/%d = Like/RT/Imp/Quote count\n", $prestr, " ", $plike, $prt, $pimp, $pquote;

		for my $media ( @{ $post->{includes}->{media} } ) {
			$returnstr .= expand_media($prestr, $media);
		}
		for my $mkey (@{ $post->{attachments}->{media_keys} }) {
			#print "\nmkey: $mkey\n";
			if (!defined($mmemcache->{$mkey})) {
				print "mmemcache EEXIST for $mkey\n";
				next;
			}
			$returnstr .= expand_media($prestr, $mmemcache->{$mkey} );
		}
		my $likestr = "";
		for my $user (sort { $a->{username} cmp $b->{username} } @{ $pmemcache->{$tid}->{liking_users} }) {
			$likestr .= "\@".$user->{username}.", ";
		}
		if (length($likestr) > 0) {
			$likestr = "Liked by ".$pmemcache->{$tid}->{liking_count}.": ".$likestr;
			$likestr =~ s/, $//;
			$returnstr .= sprintf "%s%25s %s\n", $prestr, " ", $likestr;
		}

		$returnstr .= $text;
		#$returnstr .= "${prestr} post dump: ".Dumper($post)."\n\n";
	}

	return $returnstr;

}

sub expand_media {
	my ($prestr, $media) = @_;

	#print "\nexpand_media for mkey ".$media->{media_key}."\n";

	my $returnstr = "";
	if ($media->{type} =~ /^(photo)/) {
		$returnstr .= sprintf "%s%25s    %s\n", $prestr, " ", $media->{url};
		return $returnstr;
	}
	if ($media->{type} =~ /^(video|animated_gif)/) {
		my $vc = $media->{public_metrics}->{view_count};
		if (defined($vc)) {
			$returnstr .= sprintf "%s%25d views\n", $prestr, $vc;
		}
		for my $vr ( @{ $media->{variants} } ) {
			$vr->{content_type} =~ s/application/app/;
			my $bitrate = $vr->{bit_rate};
			my $xtra = "";
			if (defined($bitrate)) {
				if ($bitrate > 0) {
					$xtra = " (bitrate: $bitrate)";
				}
			}

			$returnstr .= sprintf "%s%25s    %s%s\n", $prestr,
			    $vr->{content_type}, $vr->{url}, $xtra;
		}
		return $returnstr;
	}
	$returnstr .= sprintf "%s%20s    %s\n", $prestr, " ", Dumper($media);
	return $returnstr;
}
sub show_ustats {
	my ($handle) = @_;

	# https://developer.x.com/en/docs/twitter-api/users/lookup/api-reference/get-users-by-username-username
	# epansions=pinned_tweet_id
	# user.fields=public_metrics,username,verified,verified_type,withheld,...
	my $xtra = "";
	$xtra .= "?";
	if (defined $fields->{x}) {
		$xtra .= "expansions=".$fields->{x};
		$xtra .= "&";
	}
	if (defined $fields->{u}) {
		$xtra .= "user.fields=".$fields->{u};
		$xtra .= "&";
	}
	if (defined $fields->{p}) {
		$xtra .= "tweet.fields=".$fields->{p};
	}
	my @list = getuser_byname($handle);
	my $data = $list[0];
	my $id = $data->{id};

	my ($res,$c) = get2("users/$id$xtra");
	if (!defined($res)) {
		die("empty result querying $handle");
	}
	$data = $res->{data};
	if (!defined($data)) {
		if (defined $res->{errors}) {
			fmt_errors($res->{errors});
			return;
		}
		die("empty data ".Dumper($res));
	}
	my $verify;
	if ($data->{verified}) {
		$verify=sprintf "(%s)", $data->{verified_type};
	} else {
		$verify="";
	}
	my $url="";
	if (defined($data->{url})) {
		$url=", url ".$data->{url};
	}
	#print Dumper($data);
	my $pm=$data->{public_metrics};
	my $output = "";
	$output = sprintf "%s%s[%d]: ", $data->{username}, $verify, $data->{id};
	$output.= sprintf " %d following, %d statuses, %d followers, %d listed%s\n",
		$pm->{following_count},
		$pm->{tweet_count},
		$pm->{followers_count},
		$pm->{listed_count},
		$url;
	if (!defined($opt_q)) {
		print $output;
	}
	if (!defined($opt_N)) {
		syslog('info', $output);
	}
	
}

sub get_creds {
	if (defined($me_glob)) {
		return $me_glob;
	}
	my $ck = "get.account.verifiy_credentials";
	my $data = read_from_cache($ck);
	if (defined($data)) {
		$me_glob = $data;
		return $me_glob;
	}
	my ($me_glob, $c) = get1("account/verify_credentials");
	if ($v>0) {
		print "v1 get query=account/verify_credentials\n";
	}
	write_to_cache($ck, $me_glob);
	return $me_glob;
}


sub show_mystats {
	my $me = get_creds();
	if (defined($me) && $v > 0) {
		print Dumper($me);
	}
	my $uinfo = uinfo();
	my $favs = $me->{favourites_count};
	my $friends = $me->{friends_count};
	my $statuses = $me->{statuses_count};
	my $followers = $me->{followers_count};
	my $listed = $me->{listed_count};
	my $screen_name = $me->{screen_name};
	my $id = $uinfo->{id};
	my $verified = $uinfo->{verified};
	my $verified_type = $uinfo->{verified_type};
	my $subscription_type = $uinfo->{subscription_type};
	if (!defined($opt_q)) {
		printf "uinfo: id=%s, verified=%s, verified_type=%s, subscription_type=%s\n",
			$id, $verified, $verified_type, $subscription_type;
	}
	my $output = "";
	$output .= sprintf "%s: ", $screen_name;
	$output .= sprintf " %d favs, %d friends, %d statuses, %d followers, %d listed\n",
		$favs, $friends, $statuses, $followers, $listed;
	if (!defined($opt_q)) {
		print $output;
	}
	if (!defined($opt_N)) {
		syslog('info', $output);
	}
	#print Dumper($me)."\n";
	if ($v<1) {
		return;
	}

	# seems this is unlimited calls?
	($data, $c) = get1("account/settings");
	my $seen = { };
	for my $v (('allow_contributor_request', 'allow_dms_from',
		'language')) {
		$seen->{$v} = 1;
		print "Account $v: ".$data->{$v}, "\n";
	}
	for my $v (sort keys %{$data}) {
		if (defined($seen->{$v})) {
			next;
		}
		if (defined($data->{$v}) && ref($data->{$v}) eq "") {
			print "Account $v= ".$data->{$v}."\n";
			next;
		}
		if (ref($data->{$v}) eq "HASH") {
			my %info = %{$data->{$v}};
			for my $t (sort keys %info) {
				print "Account ${v}{$t}= ".$info{$t}."\n";
			}
			next;
		}
		print " data->{$v} is a ".ref($data->{$v}).": ";
		print Dumper($data->{$v})."\n";
	}
}
sub show_owned_lists {
	my ($handle) = @_;

	my $data;
	my @list = getuser_byname($handle);
	$data = $list[0];
	my $id = $data->{id};


	($data, $c) = get2("users/${id}/owned_lists");
	if ($v>0) {
		print "owned lists: ", Dumper($data), "\n\n";
	}
	for my $d (@{ $data->{data} }) {
		printf "%20d %s\n", $d->{id}, $d->{name};
	}
}

sub show_bookmarks {

	my ($data, $c);

	my $id = uinfo()->{id};
	my $maxres=100;
	($data, $c) = get2("users/${id}/bookmarks");
		# "?max_results=${maxres}&id=${id}");
	print "bookmarks: ", Dumper($data), "\n\n";
}

sub get1 {
	my ($call) = @_;
	my ($data, $c) = _call(1, "get", $call);
	return ($data, $c);
}
sub get2 {
	my ($call,$req) = @_;
	my ($data, $c) = _call(2, "get", $call);
	return ($data, $c);
}
sub post1 {
	my ($call,$req) = @_;
	my ($data, $c) = _post(1, $call, $req);
	return ($data, $c);
}
sub post2 {
	my ($call,$req,$cb) = @_;
	my ($data, $c) = _post(2, $call, $req, $cb);
	return ($data, $c);
}
sub _post {
	my ($rev, $call,$req,$cb) = @_;
	my $payload = { };
	$payload->{"-to_json"} = $req;
	if ($v>0) {
		print "_post payload = ".Dumper($payload);
	}
	my ($data, $c) = _call($rev, "post", $call, $payload, $cb);
	if ($v>0) {
		print Dumper(($data,$c));
	}
	return ($data,$c);
}
sub delete2 {
	my ($call,$req) = @_;
	my ($data, $c) = _call(2, "delete", $call);
	return ($data, $c);
}


sub _call {
	my ($ver, $type, $query, $pdata, $callback) = @_;
	my $name = $query;
	$name =~ s/\?.*$//;
	$name =~ s/\/[0-9]{1,}/\/:id/;
	my ($data, $c);

	my $legit = 0;
	for my $t (("get","post","delete","head")) {
		if ($t eq $type) {
			$legit++;
			last;
		}
	}
	if ($legit < 1) {
		die(sprintf("_call($ver, '${type}', %s): unhandled type", $query));
	}

	# XXX once limits are cached (fs or db), we can be 'smart' and
	#     wait before we get an error.  For now, react to errors.

	my $savedata = thaw(freeze({ data=> $pdata }));
	_redo_action:
	if ($v>0 && $opt_q < 1) {
		printf "v%d %s query=%s @ %s\n",
			$ver, $type,
			$query, strftime( "%Y%m%d %H:%M:%S", localtime());
		if ($type eq "post" && $v>0) {
			print "   payload: ".Dumper($pdata);
		}
	}
	eval {
		($data, $c) = $client->{$ver}->request($type => $query, $pdata);
	};
	$pdata = $savedata->{data};
	if ($v>0 && $type eq "post") {
		print "   pdata after request: ".Dumper($pdata);
	}
	$c //= $client->{$ver}->{_last_context};
	if ($v>0) {
		print "data: ".Dumper($data)."\n";
		print "c: ".Dumper($c)."\n";
	}
	if (!defined $c) {
		die("\$c is undef");
	}
	my $hdrs = parse_headers($c);
	show_limits($name, $hdrs->{lims});
	if (! $c->{http_response}->is_success) {
		my $content = $c->{http_response}->decoded_content;
		my $data = $client->{$ver}->from_json($content);
		if (!defined $data) {
			print "data = undef, hmm. c: \n";
			print Dumper($c);
			die("_call status failure");
		}
		my $err = "";
		if (defined $data->{status}) {
			$err .= $data->{status};
		} else {
			$err .= "???";
		}
		if (defined $data->{title}) {
			$err .= ": ".$data->{title};
		}
		if ($data->{title} ne $data->{detail}) {
			$err .= ": ".$data->{detail};
		}
		if (defined $data->{errors}) {
			for my $iter (sort @{ $data->{errors} }) {
				for my $ename (sort keys %{ $iter }) {
					$err .= ": error.$ename = ".$iter->{$ename};
				}
			}
		}
		if (defined $data->{type} && $data->{type} ne "about:blank") {
			$err .= "\n      ".$data->{type};
		}
		$err .= "\n";
		my $estat = "";
		if ($v>0) {
			for my $s (sort keys %{$hdrs->{stats}}) {
				$estat .= sprintf "\t%s = %s\n", $s, $hdrs->{stats}->{$s};
			}
			$estat .= "\n";
		}
		if ($data->{detail} eq "Unauthorized") {
			print STDERR $err.$estat;
			die("Auth failure");
		}
		if ($data->{detail} eq "Too Many Requests") {
			print STDERR $err.$estat;
			# sometimes X return a time in the past, so ensure rapid retry doesn't occur
			sleep(600);
			if (check_limits($name, $hdrs->{lims})) {
				goto _redo_action;
			}
		}
		if (defined $data->{status} && defined $data->{title} &&
			$data->{status} eq "403" && $data->{title} eq "Forbidden") {
			if (! (defined $callback && defined $data->{detail} &&
				$data->{detail} =~ /not permitted to create a non Community/) ) {
				print STDERR $err.$estat;
				die("You have hit a wall.  You have hit a wall.");
			}
			print STDERR $err.$estat;
			print "Callback .. to populate missing community_id\n";
			($data, $c) = $callback->($ver,$type,$query,$pdata,$c);
			return ($data, $c);
		}
		print STDERR $err.$estat;
		die("Today is a good day to die.");
	}
	return ($data, $c);
}

sub wait_till {
	my ($name, $reset) = @_;

	my $now = strftime( "%s", localtime());
	my $res = strftime( "%s", localtime($reset));
	my $rhu = strftime( "%Y%m%d %H:%M:%S", localtime($reset));
	my $sleeps = ($res - $now)*1.5;
	my $stm = strftime( "%Y%m%d %H:%M:%S", localtime($now+$sleeps));
	if ($res <= $now) {
		printf STDERR "%s: wait_till(%ds) <= %s, returning\n",
			$name, $res - $now, $rhu;
		return;
	}
	printf STDERR "\n%s: wait_till waiting %ds until %s, reset at %s", $name, $sleeps, $stm, $rhu;
	sleep($sleeps); # should we +1 to not be too fast?
	printf STDERR " done.\n";
}

sub file_to_mediaid {
	my ($file) = @_;

	open(FH, "<", $file);
	my $sha = Digest::SHA1->new;
	$sha->addfile(*FH);
	close(FH);

	my $filesha = $sha->hexdigest;
	my $data = read_from_cache($filesha, 0);
	if (defined($data)) {
		return $data;
	}

	my $mti = {
		'JPEG format' => 'image/jpeg',
		'JFIF format' => 'image/jpeg',
		'PNG format'  => 'image/png',
		'Portable Network Graphics' => 'image/png',
		'GIF format'  => 'image/gif',
		'CompuServe graphics interchange format' => 'image/gif',
		'ASCII Text' => 'text/plain',
		'Portable Document Format' => 'application/pdf',
	};

	# verified not supported
	#	'X pixmap' => 'image/x-xpixmap',

	my $img = Graphics::Magick->new;

	my $status = $img->Read($file);
	if ($status) {
		if ($status =~ /^Exception 420/) {
			# detect video and do https://developer.x.com/en/docs/twitter-api/v1/media/upload-media/uploading-media/chunked-media-upload
			$data = video_to_mediaid( $file );
			write_to_cache($filesha, $data);
			return $data;
		}
	}
	warn $status if "$status";
	my $format = $img->Get('format');
	if (defined($format)) {
		print "format=$format for $file\n";
	}
	my $mt;
	if (defined($format)) {
		for my $f (keys %{ $mti }) {
			if ($format =~ /$f$/) {
				$mt = $mti->{$f};
			}
		}
	}
	if (!defined($mt)) {
		die("file_to_mediaid($file) format='$format' unsupported");
	}
	my ($media_data) = $img->ImageToBlob();
	my $encoded_image = encode_base64($media_data);
	my $payload = {
		media_type => $mt,
		media_data => $encoded_image,
		media_category => ($mt eq "image/gif") ? 'tweet_gif' : 'tweet_image',
	};
	if ($v>1) {
		print "payload: ".Dumper($payload);
	}
	my $query = $client->{1}->upload_url_for('media/upload');
	eval {
		($data, $c) = $client->{1}->request(post => $query, $payload);
	};
	if ($@) {
		die(sprintf("post1(%s):\n%s",$query,$@));
	}
	#print "post.media.upload: data ".Dumper($data);
	#print "post.media.upload: c ".Dumper($data);
	# see json/post.media.upload.data.json for both
	printf "mid %d from %s %dx%d %s\n", $data->{media_id}, 
		$file,
		$data->{image}->{h},
		$data->{image}->{w},
		$data->{image}->{image_type};
	write_to_cache($filesha, $data);
	return $data;
}
sub write_magic {
	my ($mfile) = @_;
	open(I,'<','/etc/magic');
	open(O,'>',$mfile);
	while(<I>) {
		next if /^#/;
		next if /:(ext|mime|apple|strength)/i;
		next if /(ustring|bequad)/;
		print O $_;
	}
	close(I);
	close(O);
}
sub check_vid_mime_type {
	my ($file) = @_;

	if (!defined $magic) {
		my $mfile = "$cachedir/magic";
		if (! -f $mfile) {
			write_magic($mfile);
		}
		$magic = File::MMagic->new($mfile);
	}
	my $mime_type = $magic->checktype_filename($file);

	my $mtypes = { 
		'Macromedia Flash Video' => 'application/x-shockwave-flash',
		'MP4 Base Media' => 'video/mp4',
		'QuickTime movie' => 'video/quicktime',
		'Microsoft ASF' => 'video/x-ms-asf',
		', AVI,' => 'video/ms-video',
		'MPEG sequence' => 'video/mpeg',
		'WAVE audio' => 'audio/x-wav',
	};
	for my $m (keys %{$mtypes}) {
		if ($mime_type =~ /${m}/) {
			return $mtypes->{$m};
		}
	}

	die("unknown: ${mime_type}");
}
sub video_to_mediaid {
	my ($file) = @_;

	my $mtype = check_vid_mime_type($file);
	printf "mtype = '%s'\n", $mtype;
	my $chunk_size = 4 * 1024 * 1024; # 1mb, max 5mb
	if (defined($opts->{chunksize})) {
		$chunk_size = $opts->{chunksize};
	}
	my @stats = stat($file);
	my $size = $stats[7];
	my $cdata = chunk_init($mtype, $size);
	#print "video_to_mediaid: init cdata ".Dumper($cdata);
	#printf "video_to_mediaid(%s) media_key = '%s', media_id = '%s'\n", $file, $cdata->{media_key}, $cdata->{media_id};
	my $expiration = time() + $cdata->{expires_after_secs} - 1;
	my $mid = $cdata->{media_id};

	open(my $fh, '<:raw', $file) or die "video_to_mediaid: Cannot open $file: $!";
	binmode $fh;
	my $chunk = '';
	my $chunk_num = 0;
	my $chunk_sent = 0;
	while(read($fh, $chunk, $chunk_size) != 0) {
		$cdata = chunk_append($mid, $chunk, $chunk_num++);
		$chunk_sent += length($chunk);
	}
	close($fh);
	$cdata = chunk_finalize($mid);
	chunk_check_status($cdata);
	return $cdata;
}

# https://developer.x.com/en/docs/x-api/v1/media/upload-media/uploading-media/media-best-practices
sub chunk_init {
	my ($type, $size) = @_;
	printf "chunk_init(%s, %d)\n", $type, $size;

	my $payload = { };
	$payload->{'command'} = "INIT";
	$payload->{'media_type'} = $type;
	$payload->{'media_category'} = 'tweet_video';
	$payload->{'total_bytes'} = $size;

	my $query = $client->{1}->upload_url_for('media/upload');
	eval {
		($data, $c) = $client->{1}->request(post => $query, $payload);
	};
	if ($@) {
		die(sprintf("chunk_init: client->{1}(%s, { media_type => $type, total_bytes => $size }: %s",$query,$@));
	}
	return $data;
}
sub chunk_append {
	my ($mid, $chunk, $chunk_num) = @_;
	printf "chunk_append(%s, len(chunk)=%d, %s)\n", $mid, length($chunk), $chunk_num;

	my $payload = { };
	$payload->{'command'} = "APPEND";
	$payload->{'media_id'} = $mid;
	$payload->{'segment_index'} = $chunk_num;
	$payload->{'media_data'} = encode_base64($chunk);


	my $query = $client->{1}->upload_url_for('media/upload');
	eval {
		($data, $c) = $client->{1}->request(post => $query, $payload);
	};
	if ($@) {
		die(sprintf("chunk_append: client->{1}($query, { media_id => $mid, segment_index => ${chunk_num} }: %s",$@));
	}
	return $data;
}
sub chunk_finalize {
	my ($mid) = @_;
	printf "chunk_finalize(%s)\n", $mid;

	my $payload = { };
	$payload->{'command'} = "FINALIZE";
	$payload->{'media_id'} = $mid;

	my $query = $client->{1}->upload_url_for('media/upload');
	eval {
		($data, $c) = $client->{1}->request(post => $query, $payload);
	};
	if ($@) {
		die(sprintf("chunk_finalize: client->{1}($query, { media_id => $mid }: %s",$@));
	}
	#print "video_to_mediaid: finalize cdata ".Dumper($data);
	return $data;
}
sub chunk_check_status {
	my ($data) = @_;

	my $pi = $data->{'processing_info'};

	if (!defined($pi)) {
		print "chunk_check_status no pi? dumping data: ".Dumper($data);
		return;
	}
	my $query = $client->{1}->upload_url_for('media/upload');
	while (1)
	{
		printf "chunk_check_status: %s, sleep %ds\n", $pi->{state}, $pi->{'check_after_secs'};
		sleep($pi->{'check_after_secs'} * 2);
		my $payload = { };
		$payload->{'command'} = "STATUS";
		$payload->{'media_id'} = $data->{media_id};

		eval {
			($data, $c) = $client->{1}->request(get => $query, $payload);
		};
		if ($@) {
			my $msg = sprintf("chunk_check_status: state=%s, check_after_secs=%s: %s\n",
				$data->{'processing_info'}->{state},
				$data->{'processing_info'}->{'check_after_secs'},
				$@
			);
			die($msg);
		}
		$pi = $data->{'processing_info'};
		if ($pi->{state} =~ /^(failed|succeeded)/) {
			last;
		}
	}

}

sub like {
	my (@args) = @_;
	if (!defined($args[0])) {
		die "called like with no post to like";
	}
	my $req = { };
	$req->{tweet_id} = $args[0];
	if ($v>0) {
		print "like req = { ".Dumper($req)." }\n";
	}
	my $uid = uinfo()->{id};
	($data, $c) = post2("users/${uid}/likes", $req);
	print Dumper($data);
}
sub desc {
	my (@args) = @_;
	if (!defined($args[0])) {
		die "called desc with no args";
	}
	my ($mid, $text) = @args;
	set_alt_text($mid, $text);
}
sub set_alt_text {
	my ($mid, $text) = @_;

	if (length($text) > 1000) {
		printf "Alt text for media_id %d is %d bytes:\n", $mid, length($text);
		printf "   '%s'\n", $text;
		# verified as of 20240805 11:26:42 enforced
		return;
	}

	my $params = {
		media_id => "${mid}",
		alt_text => {
			text => "${text}",
		},
	};
	($data, $c) = post1("media/metadata/create", $params);
	#print "post.media.metadata.create: data ".Dumper($data);
	# surprisingly, $VAR = ''
	#print "post.media.metadata.create: c ".Dumper($c);
	# see json/post.media.metadata.create.c.json
	if ($v>1) {
		print "media/metadata/create result:\n".Dumper($data);
	}
}
sub key_to_cache_filename {
	my ($key) = @_;
	my $filename = $cachedir."/".sha1_hex($key);
	return $filename;
}
sub write_to_cache {
	my ($key, $data) = @_;
	my $filename = key_to_cache_filename($key);
	if (!defined($data)) {
		printf "Cache but no data %d\n", $filename;
		return;
	}

	if (!defined($opt_q)) {
		print "Cache write $filename ($key)\n";
	}
	open my $fh, '>', $filename or die "Could not open file '$filename': $!";
	print $fh freeze($data);
	close $fh;
}
sub read_from_cache {
	my ($key, $ttl) = @_;
	my $filename = key_to_cache_filename($key);
	if (!defined($ttl)) {
		$ttl = 3600;
	}
	if (!-e $filename) {
		return undef;
	}
	if ($ttl != 0) {
		if ( (time - (stat($filename))[9]) > $ttl) {
			unlink($filename);
			return undef;
		}
	}
	my $fh;
	if (!open($fh, '<', $filename)) {
		#if ($v>1) {
			warn "Could not open file '$filename': $!";
		#}
		return undef;
	}
	if ($v>0) {
		print "Cache read $filename ($key)\n";
	}
	local $/ = undef;  # Read the entire file at once
	my $data = thaw(<$fh>);
	close $fh;
	if ($v>0) {
		print "read_from_cache($key) success!\n";
	}
	return $data;
}
sub parse_headers {
	my ($c) = @_;

	my $lims = { };
	my $stats = { };
	if ($v>0) {
		print STDERR "Headers:\n";
	}
	my $resp = $c->http_response;
	for my $h ($resp->header_field_names) {
		my $val = $resp->header($h);
		if (! defined $val) {
			next;
		}
		if ($h =~ /x-(.*)-(limit|remaining|reset)/i) {
			my $lim = $1;
			my $ltype = lc($2);
			if ($v>0) {
				printf STDERR "\t.. %s .. %s\n", $lim, $ltype;
			}
			$lims->{$lim}->{$ltype} = $val;
			next;
		}
		if ($h =~ /^(x-(con|res|tran|acc)|cont|date|server|api)/i) {
			$stats->{$h} = $val;
			next;
		}
		if ($v>0) {
			printf STDERR "\t!header handled: %s = '%s'\n", $h, $resp->header($h);
		}
	}
	if ($v>0) {
		print STDERR "\n";
	}
	my $tmp = {
		lims => $lims,
		stats => $stats,
	};
	return $tmp;
}
sub check_limits {
	my ($name, $lims) = @_;
	my $timestamp = Date::Manip::Date->new();
	my $wait = 0;
	for my $lim (keys %{ $lims }) {
		if ($lims->{$lim}->{remaining} < 1) {
			$timestamp->parse("epoch ".$lims->{$lim}->{reset});
			printf STDERR "Matched limit %s.%s { %d/%d, %s }...\n",
				$name, $lim,
				$lims->{$lim}->{remaining},
				$lims->{$lim}->{limit},
				$timestamp->printf("%Y%m%d %H:%M:%S");
			my $thiswait = $lims->{$lim}->{reset};
			if ($thiswait < 1) {
				warn("lim ${name}.$lim reset is $thiswait");
				continue;
			}
			if ($wait < 1 || ( $wait > 0 && $wait > $thiswait ) ) {
				$wait = $thiswait;
			}
		} else {
			$timestamp->parse("epoch ".$lims->{$lim}->{reset});
			printf STDERR "!Matched limit %s.%s { %d/%d, %s }...\n",
				$name, $lim,
				$lims->{$lim}->{remaining},
				$lims->{$lim}->{limit},
				$timestamp->printf("%Y%m%d %H:%M:%S");
		}
	}
	if ($wait > 0) {
		wait_till($name, $wait);
		return 1;
	}
	return 0;
}
sub show_limits {
	my ($name, $lims) = @_;
	my $timestamp = Date::Manip::Date->new();

	for my $lim (keys %{ $lims }) {
		$timestamp->parse("epoch ".$lims->{$lim}->{reset});
		printf "  %s.%s = {%d/%d, %s}\n", $name, $lim,
			$lims->{$lim}->{remaining},
			$lims->{$lim}->{limit},
			$timestamp->printf("%Y%m%d %H:%M:%S");
	}
}

sub xpost {
	my ($msg) = @_;
	my $query = "posts";
	my $name = $query;
	my $uinfo = uinfo();
	my $maxsize=240;
	if ($uinfo->{subscription_type} eq "PremiumPlus") {
		$maxsize=24959;
	}
	if (length($msg) > $maxsize) {
		my $msgleft = $msg;
		my $count=1;
		# XXX redo loop so while(1) to avoid duplication after the loop
		while (length($msgleft) > $maxsize) {
			printf "msgleft='%s'\n", $msgleft;
			my $thismemo = "";
			if ($count > 1) {
				$thismemo = sprintf "%d/ ", $count;
			}
			my $newmsg = $thismemo.$msgleft;
			my $poststr;
			($poststr, $msgleft) = xsplitmsg($newmsg, $maxsize);
			printf "poststr='%s'\n", $poststr;
			printf "msgleft='%s'\n", $msgleft;
			my $post = xpost($poststr);
			if (defined $post->{id}) {
				$opt_W = $post->{id};
			}
		}
		if (length($msgleft) > 0) {
			printf "msgleft='%s'\n", $msgleft;
			my $thismemo = "";
			if ($count > 1) {
				$thismemo = sprintf "%d/ ", $count;
			}
			my $poststr = $thismemo.$msgleft;
			printf "poststr='%s'\n", $poststr;
			xpost($poststr);
		}
		return;
	}
	my $req = {
			text => $msg,
	};
	if (defined($opt_W)) {
		my $reply = {
			"in_reply_to_tweet_id" => $opt_W,
		};
		$req->{"reply"} = $reply;
	} elsif (defined($opt_Q)) {
		$req->{"quote_tweet_id"} = $opt_Q;
	}
	if (defined($opt_C)) {
		$req->{"community_id"} = $opt_C;
	}
	if (defined($opt_R)) {
		$req->{"reply_settings"} = $opt_R;
	}
	# $opt_I syntax:
	# <img> = foo.jpg[="alternate text"]
	# list = <img>[,<img>...]
	# 
	if (defined($opt_I)) {
		my @ids;
		my ($mdata, $mstr, $mid);
		for my $img (split(/,/, $opt_I)) {
			my ($f,$txt)=split(/=/,$img);
			if ($f =~ /^[0-9]+$/) {
				$mid = $f;
			} else {
				$mdata = file_to_mediaid( $f );
				$mid = $mdata->{media_id};
			}
			$mstr = sprintf("%s", $mid);
			if ($v>0) {
				printf " media_id %s from %s\n", $mstr, $f;
			}
			push @ids, $mstr;
			# XXX make conditional
			if (defined($txt)) {
				set_alt_text( $mid, $txt );
			}
		}
		my $media = {
			media_ids => [ @ids ],
		};
		$req->{media} = $media;
	}
	# $req->{for_super_followers_only} = "true";
	# $req->{reply_settings} = "mentionedUsers";
	# $req->{geo} = $geoobj; ?
	# $req->{geo}->{place_id} = $geo_place_id;

	# media | poll | quote
	# $req->{poll} = $poll;

	my $uname = $uinfo->{username};
	#print "uinfo: ".Dumper($uinfo);
	# see json/uinfo.json

	my ($data, $c) = post2($query, $req, sub {
		my ($ver, $type, $call, $pdata, $c) = @_;
		printf "sub ($ver,$type,$call,%s, %s) starting\n", ref($pdata), ref($c);
		my $req = $pdata->{'-to_json'};
		print "cb pdata: ".Dumper($pdata);
		print "cb   req: ".Dumper($req);
		my $cid = $req->{"community_id"};
		if (defined $cid) {
			if ($v>0) {
				print "cid=$cid oops\n";
			}
			return (undef, undef);
		}
		if (!defined $opt_W) {
			if ($v>0) {
				print "opt_W=undef oops\n";
			}
			return (undef, undef);
		}
		print "sub get2(posts/${opt_W}?tweet.fields=community_id\n";
		my $data;
		($data, $c) = get2("posts/${opt_W}?tweet.fields=community_id");
		$cid = $data->{data}->{community_id};
		if (!defined $cid) {
			printf "No cid for $opt_W\n";
			sleep(1);
			return (undef, undef);
		}
		$req->{"community_id"} = $cid;
		($data, $c) = post2($query, $req);
		return ($data, $c);
	});

	my $postid = $data->{data}->{id};
	my $txt = $data->{data}->{text};
	print "https://x.com/${uname}/status/${postid} \"${txt}\"\n";
	#print "post.posts.<msg> c: ".Dumper($c);
	# see json/post.tweets.msg.json
	return $data->{data};
}

sub qfollow {
	my ($user) = @_;

	if ($user =~ /^[0-9]+$/) {
		qfollowid($user);
		return;
	}
	$user =~ s/^\@//;
	push @followq, $user;
}

sub qfollowid {
	my ($id) = @_;

	my $uid = uinfo()->{id};

	my $req = {
		target_user_id => $id,
	};
	my ($data, $c) = post2("users/${uid}/following", $req);
	printf "Follow: %s, Pending: %s\n", $data->{data}->{following}, $data->{data}->{pending_follow};
}
sub xsplitmsg {
	my ($msg, $maxsize) = @_;

	# try by line first
	my @lines = split(/\n/, $msg);
	my $line = $lines[0];
	my $poststr = $line."\n";
	# attempt to split on lines...
	if (length($line) < $maxsize) {
		my $msgleft = substr($msg, length($poststr)+1);
		my $i = 1;
		while (1) {
			$line = $lines[$i++];
			if (!defined $line) {
				return ($poststr, $msgleft);
			}
			if ( (length($poststr) + length($line) + 1) >
				$maxsize) {
				return ($poststr, $msgleft);
			}
			$poststr .= $line . "\n";
			$msgleft = substr($msgleft, length($line)+1);
		}
		die("We have reached the bermuda triangle!");
	}
	# XXX insert split on words
	# ... otherwise, split on chars.
	$poststr = substr($msg, 0, $maxsize);
	my $msgleft = substr($msg, length($poststr));
	return ($poststr, $msgleft);
}
sub fmt_errors {
	my (@elist) = @_;

	my $ecount = 0;
	for my $el (@elist) {
		printf "%3d error list\n", $ecount++;
		for my $error (@{ $el }) {
			for my $var (sort keys %{$error}) {
				printf "   %s = %s\n", $var, $error->{$var};
			}
		}
	}
}
